<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[接口与抽象类]]></title>
    <url>%2F2017%2F06%2F25%2FJava%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java抽象类包含抽象方法的类就做抽象类.如果一个类包含一个或多个抽象方法,该类必须被限定为抽象类. java接口在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 1.通过继承来扩展接口` //: interfaces/music5/Music5.java// Interfaces.package interfaces.music5;import polymorphism.music.Note;import static net.mindview.util.Print.*; interface Instrument { // Compile-time constant: int VALUE = 5; // static &amp; final // Cannot have method definitions: void play(Note n); // Automatically public void adjust();} class Wind implements Instrument { public void play(Note n) { print(this + “.play() “ + n); } public String toString() { return “Wind”; } public void adjust() { print(this + “.adjust()”); }} class Percussion implements Instrument { public void play(Note n) { print(this + “.play() “ + n); } public String toString() { return “Percussion”; } public void adjust() { print(this + “.adjust()”); }} class Stringed implements Instrument { public void play(Note n) { print(this + “.play() “ + n); } public String toString() { return “Stringed”; } public void adjust() { print(this + “.adjust()”); }} class Brass extends Wind { public String toString() { return “Brass”; }} class Woodwind extends Wind { public String toString() { return “Woodwind”; }} public class Music5 { // Doesn’t care about type, so new types // added to the system still work right: static void tune(Instrument i) { // … i.play(Note.MIDDLE_C); } static void tuneAll(Instrument[] e) { for(Instrument i : e) tune(i); } public static void main(String[] args) { // Upcasting during addition to the array: Instrument[] orchestra = { new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() }; tuneAll(orchestra); }} / Output:Wind.play() MIDDLE_CPercussion.play() MIDDLE_CStringed.play() MIDDLE_CBrass.play() MIDDLE_CWoodwind.play() MIDDLE_C ///:~ ` 2.组合接口时的名字冲突3.适配接口接口中最吸引人的原因之一就是允许同一个接口具有多个不同的具体方法实现. 4.接口中的域接口中的任何域都自动是static和final的,所以接口就成为了一种便捷的用来建常量组的工具 接口与抽象类的区别 变量 构造方法 方法 抽象类 无限制 子类通过构造方法链调用构造方法,抽象类不能用new操作符实例haunted 无限制 接口 所有的变量必须时是public Static 没有构造方法,接口不能用new操作符实例化 所有方法必须是公共的抽象实例方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBootDayOnelearn]]></title>
    <url>%2F2017%2F06%2F10%2FspringBootDayOnelearn%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysqlSQL语句练习]]></title>
    <url>%2F2017%2F06%2F10%2FmysqlSQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础枚举类型]]></title>
    <url>%2F2017%2F06%2F10%2FJava%E5%9F%BA%E7%A1%80%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础异常]]></title>
    <url>%2F2017%2F06%2F10%2Fjava%E5%9F%BA%E7%A1%80%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础泛型]]></title>
    <url>%2F2017%2F06%2F10%2Fjava%E5%9F%BA%E7%A1%80%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础多态]]></title>
    <url>%2F2017%2F06%2F09%2Fjava%E5%9F%BA%E7%A1%80%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础继承]]></title>
    <url>%2F2017%2F06%2F09%2Fjava%E5%9F%BA%E7%A1%80%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础封装]]></title>
    <url>%2F2017%2F06%2F09%2Fjava%E5%9F%BA%E7%A1%80%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础多线程]]></title>
    <url>%2F2017%2F06%2F09%2Fjava%E5%9F%BA%E7%A1%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础IO]]></title>
    <url>%2F2017%2F06%2F09%2Fjava%E5%9F%BA%E7%A1%80IO%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java基础集合]]></title>
    <url>%2F2017%2F06%2F08%2Fjava%E5%9F%BA%E7%A1%80%E9%9B%86%E5%90%88%2F</url>
    <content type="text"></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>